import { NextResponse } from "next/server";
import * as cheerio from "cheerio";

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–µ—Ü–µ–ø—Ç–∞
interface ImportedRecipe {
  title: string;
  description?: string;
  imageUrl?: string;
  prepTime?: number; // –º–∏–Ω—É—Ç—ã
  cookTime?: number; // –º–∏–Ω—É—Ç—ã
  servings?: number;
  cuisine?: string;
  tags: string[];
  ingredients: Array<{
    name: string;
    amount: string;
    unit: string;
    note?: string;
  }>;
  steps: Array<{
    text: string;
  }>;
  sourceUrl: string;
  sourceDomain?: string;
  confidence: "high" | "medium" | "low"; // –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–∞—Ä—Å–∏–Ω–≥–∞
}

export async function POST(request: Request) {
  try {
    const { url } = await request.json();

    if (!url || typeof url !== "string") {
      return NextResponse.json(
        { error: "URL is required" },
        { status: 400 }
      );
    }

    console.log("üåê –ò–º–ø–æ—Ä—Ç —Ä–µ—Ü–µ–ø—Ç–∞ –∏–∑:", url);

    // –ó–∞–≥—Ä—É–∂–∞–µ–º HTML —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    const response = await fetch(url, {
      headers: {
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Accept-Language": "ru,en-US;q=0.9,en;q=0.8",
      },
    });

    if (!response.ok) {
      console.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏:", response.status, response.statusText);
      return NextResponse.json(
        { error: "Failed to fetch URL", details: response.statusText },
        { status: 400 }
      );
    }

    const html = await response.text();
    console.log("‚úÖ HTML –∑–∞–≥—Ä—É–∂–µ–Ω, —Ä–∞–∑–º–µ—Ä:", html.length, "–±–∞–π—Ç");

    // –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å —Ä–µ—Ü–µ–ø—Ç —Ä–∞–∑–Ω—ã–º–∏ —Å–ø–æ—Å–æ–±–∞–º–∏
    let recipe: ImportedRecipe | null = null;
    let method = "";

    // 1. –ü—Ä–æ–±—É–µ–º JSON-LD Schema.org (–ª—É—á—à–∏–π –≤–∞—Ä–∏–∞–Ω—Ç)
    recipe = extractFromJsonLD(html, url);
    if (recipe) {
      method = "JSON-LD Schema.org";
      console.log("‚úÖ –†–µ—Ü–µ–ø—Ç –∏–∑–≤–ª–µ—á—ë–Ω —á–µ—Ä–µ–∑ JSON-LD");
    }

    // 2. –ï—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å, –ø—Ä–æ–±—É–µ–º —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –ø–∞—Ä—Å–µ—Ä—ã –¥–ª—è –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö —Å–∞–π—Ç–æ–≤
    if (!recipe) {
      recipe = extractFromKnownSites(html, url);
      if (recipe) {
        method = "Site-specific parser";
        console.log("‚úÖ –†–µ—Ü–µ–ø—Ç –∏–∑–≤–ª–µ—á—ë–Ω —á–µ—Ä–µ–∑ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–π –ø–∞—Ä—Å–µ—Ä");
      }
    }

    // 3. –ó–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç: OpenGraph + –±–∞–∑–æ–≤—ã–π –ø–∞—Ä—Å–∏–Ω–≥ HTML
    if (!recipe) {
      recipe = extractFromOpenGraphAndHtml(html, url);
      method = "OpenGraph + HTML fallback";
      console.log("‚ö†Ô∏è –†–µ—Ü–µ–ø—Ç –∏–∑–≤–ª–µ—á—ë–Ω —á–µ—Ä–µ–∑ fallback (–Ω–∏–∑–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ)");
    }

    if (!recipe) {
      return NextResponse.json(
        {
          error: "Recipe not found",
          message: "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ä–µ—Ü–µ–ø—Ç –Ω–∞ —ç—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥—É—é —Å—Å—ã–ª–∫—É –∏–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ —Ä–µ—Ü–µ–ø—Ç –≤—Ä—É—á–Ω—É—é.",
        },
        { status: 404 }
      );
    }

    return NextResponse.json({
      recipe,
      meta: {
        method,
        timestamp: new Date().toISOString(),
      },
    });
  } catch (error) {
    console.error("‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ —Ä–µ—Ü–µ–ø—Ç–∞:", error);
    return NextResponse.json(
      {
        error: "Import failed",
        message: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}

// ============================================================================
// 1. –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏–∑ JSON-LD Schema.org
// ============================================================================

function extractFromJsonLD(html: string, sourceUrl: string): ImportedRecipe | null {
  try {
    // –ò—â–µ–º –≤—Å–µ <script type="application/ld+json">
    const jsonLdMatches = html.matchAll(
      /<script[^>]*type=["']application\/ld\+json["'][^>]*>(.*?)<\/script>/gis
    );

    for (const match of jsonLdMatches) {
      try {
        const jsonString = match[1].trim();
        const data = JSON.parse(jsonString);

        // –ò—â–µ–º —Ä–µ—Ü–µ–ø—Ç –≤ JSON (–º–æ–∂–µ—Ç –±—ã—Ç—å –≤–ª–æ–∂–µ–Ω –≤ @graph –∏–ª–∏ –º–∞—Å—Å–∏–≤)
        const recipe = findRecipeInJson(data);
        if (recipe) {
          return parseRecipeFromJsonLD(recipe, sourceUrl);
        }
      } catch (e) {
        console.log("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON-LD –±–ª–æ–∫–∞:", e);
        continue;
      }
    }
  } catch (e) {
    console.log("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ JSON-LD:", e);
  }

  return null;
}

function findRecipeInJson(data: any): any {
  if (!data) return null;

  // –ï—Å–ª–∏ —ç—Ç–æ –æ–±—ä–µ–∫—Ç —Å @type: "Recipe"
  if (data["@type"]) {
    const type = Array.isArray(data["@type"]) ? data["@type"] : [data["@type"]];
    if (type.some((t: string) => t.toLowerCase().includes("recipe"))) {
      return data;
    }
  }

  // –ò—â–µ–º –≤ @graph
  if (data["@graph"] && Array.isArray(data["@graph"])) {
    for (const item of data["@graph"]) {
      const found = findRecipeInJson(item);
      if (found) return found;
    }
  }

  // –ò—â–µ–º –≤ –º–∞—Å—Å–∏–≤–µ
  if (Array.isArray(data)) {
    for (const item of data) {
      const found = findRecipeInJson(item);
      if (found) return found;
    }
  }

  // –ò—â–µ–º –≤ mainEntity (–¥–ª—è QAPage –∏ —Ç.–¥.)
  if (data.mainEntity) {
    const found = findRecipeInJson(data.mainEntity);
    if (found) return found;
  }

  return null;
}

function parseRecipeFromJsonLD(data: any, sourceUrl: string): ImportedRecipe {
  const domain = new URL(sourceUrl).hostname;

  return {
    title: getString(data.name) || "–†–µ—Ü–µ–ø—Ç",
    description: getString(data.description),
    imageUrl: getImageUrl(data.image),
    prepTime: parseDuration(data.prepTime),
    cookTime: parseDuration(data.cookTime) || parseDuration(data.totalTime),
    servings: parseServings(data.recipeYield),
    cuisine: getString(data.recipeCuisine),
    tags: getStringArray(data.keywords),
    ingredients: parseIngredients(data.recipeIngredient),
    steps: parseInstructions(data.recipeInstructions),
    sourceUrl,
    sourceDomain: domain,
    confidence: "high",
  };
}

// ============================================================================
// 2. –ü–∞—Ä—Å–µ—Ä—ã –¥–ª—è —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö —Å–∞–π—Ç–æ–≤
// ============================================================================

function extractFromKnownSites(html: string, sourceUrl: string): ImportedRecipe | null {
  const domain = new URL(sourceUrl).hostname.toLowerCase();

  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–æ–π –ø–∞—Ä—Å–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
  if (domain.includes("food.ru")) {
    return parseFoodRu(html, sourceUrl);
  }
  if (domain.includes("eda.ru")) {
    return parseEdaRu(html, sourceUrl);
  }
  if (domain.includes("povarenok.ru")) {
    return parsePovarenok(html, sourceUrl);
  }
  if (domain.includes("gotovim-doma.ru")) {
    return parseGotovimDoma(html, sourceUrl);
  }
  if (domain.includes("allrecipes.com") || domain.includes("allrecipes.ru")) {
    return parseAllRecipes(html, sourceUrl);
  }

  return null;
}

function parseFoodRu(html: string, sourceUrl: string): ImportedRecipe | null {
  try {
    // Food.ru –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Next.js, –¥–∞–Ω–Ω—ã–µ –≤ __NEXT_DATA__
    const match = html.match(/<script id="__NEXT_DATA__"[^>]*>(.*?)<\/script>/s);
    if (!match) {
      console.log("‚ö†Ô∏è __NEXT_DATA__ –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–∞ food.ru");
      return null;
    }

    const nextData = JSON.parse(match[1]);
    const state = nextData?.props?.pageProps?.__EFFECTOR_NEXTJS_INITIAL_STATE__;

    if (!state) {
      console.log("‚ö†Ô∏è Effector state –Ω–µ –Ω–∞–π–¥–µ–Ω");
      return null;
    }

    // –ò—â–µ–º –¥–∞–Ω–Ω—ã–µ —Ä–µ—Ü–µ–ø—Ç–∞ –≤ state
    let recipeData: any = null;

    // –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ –∫–ª—é—á–∏ –∏ –∏—â–µ–º –æ–±—ä–µ–∫—Ç —Å –¥–∞–Ω–Ω—ã–º–∏ —Ä–µ—Ü–µ–ø—Ç–∞
    for (const key in state) {
      const value = state[key];
      if (value && typeof value === 'object') {
        // –ò—â–µ–º –æ–±—ä–µ–∫—Ç —Å –ø–æ–ª—è–º–∏ title, ingredients, steps
        if (value.title || value.name) {
          if (value.ingredients || value.steps || value.cooking_time) {
            recipeData = value;
            console.log("‚úÖ –ù–∞–π–¥–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ —Ä–µ—Ü–µ–ø—Ç–∞ –≤ –∫–ª—é—á–µ:", key);
            break;
          }
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–ª–æ–∂–µ–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
        if (value.recipe) {
          recipeData = value.recipe;
          console.log("‚úÖ –ù–∞–π–¥–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –≤ recipe");
          break;
        }

        if (value.data && value.data.recipe) {
          recipeData = value.data.recipe;
          console.log("‚úÖ –ù–∞–π–¥–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –≤ data.recipe");
          break;
        }
      }
    }

    if (!recipeData) {
      console.log("‚ö†Ô∏è –î–∞–Ω–Ω—ã–µ —Ä–µ—Ü–µ–ø—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ state");
      // Fallback: –ø—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –≤ initialProps
      const initialProps = nextData?.props?.pageProps?.initialProps;
      if (initialProps?.recipe) {
        recipeData = initialProps.recipe;
      }
    }

    if (!recipeData) return null;

    const title = recipeData.title || recipeData.name || "–†–µ—Ü–µ–ø—Ç";

    // –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã
    const ingredients: Array<{ name: string; amount: string; unit: string }> = [];
    if (Array.isArray(recipeData.ingredients)) {
      recipeData.ingredients.forEach((ing: any) => {
        const name = ing.name || ing.title || ing.product?.name || "";
        const amount = ing.amount || ing.quantity || "";
        const unit = ing.unit || ing.measure || "";

        if (name) {
          ingredients.push({
            name: name.trim(),
            amount: String(amount).trim(),
            unit: String(unit).trim(),
          });
        }
      });
    }

    // –ò–∑–≤–ª–µ–∫–∞–µ–º —à–∞–≥–∏
    const steps: Array<{ text: string }> = [];
    if (Array.isArray(recipeData.steps)) {
      recipeData.steps.forEach((step: any) => {
        const text = step.description || step.text || step.content || "";
        if (text && text.trim()) {
          // –£–±–∏—Ä–∞–µ–º "–†–µ–∫–ª–∞–º–∞" –∏ –¥—Ä—É–≥–æ–π –º—É—Å–æ—Ä
          const cleaned = text
            .replace(/–†–µ–∫–ª–∞–º–∞/g, "")
            .replace(/^\s*–®–∞–≥\s*\d+\s*/i, "")
            .trim();

          if (cleaned && cleaned.length > 5) {
            steps.push({ text: cleaned });
          }
        }
      });
    } else if (Array.isArray(recipeData.cooking_steps)) {
      recipeData.cooking_steps.forEach((step: any) => {
        const text = step.description || step.text || "";
        if (text && text.trim()) {
          const cleaned = text.replace(/–†–µ–∫–ª–∞–º–∞/g, "").trim();
          if (cleaned && cleaned.length > 5) {
            steps.push({ text: cleaned });
          }
        }
      });
    }

    return {
      title,
      description: recipeData.description || recipeData.preview_text || undefined,
      imageUrl: recipeData.image || recipeData.picture || recipeData.preview_picture || undefined,
      prepTime: parseInt(recipeData.prep_time || recipeData.preparation_time || 0) || undefined,
      cookTime: parseInt(recipeData.cooking_time || recipeData.cook_time || 0) || undefined,
      servings: parseInt(recipeData.servings || recipeData.portions || 0) || undefined,
      cuisine: recipeData.cuisine || undefined,
      tags: Array.isArray(recipeData.tags) ? recipeData.tags.map((t: any) => t.name || t.title || t) : [],
      ingredients,
      steps,
      sourceUrl,
      sourceDomain: "food.ru",
      confidence: "high",
    };
  } catch (err) {
    console.error("‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ food.ru:", err);
    return null;
  }
}

function parseEdaRu(html: string, sourceUrl: string): ImportedRecipe | null {
  const $ = cheerio.load(html);

  const title = $('h1[class*="recipe-header"]').text().trim() ||
                $('h1').first().text().trim();

  if (!title) return null;

  const ingredients: Array<{ name: string; amount: string; unit: string }> = [];
  $('[class*="ingredient"]').each((_, el) => {
    const text = $(el).text().trim();
    if (text) {
      const parsed = parseIngredientText(text);
      ingredients.push(parsed);
    }
  });

  const steps: Array<{ text: string }> = [];
  $('[class*="step"] p, [class*="instruction"] p').each((_, el) => {
    const text = $(el).text().trim();
    if (text) {
      steps.push({ text });
    }
  });

  return {
    title,
    description: $('[class*="description"]').first().text().trim() || undefined,
    imageUrl: $('img[class*="recipe"]').first().attr("src"),
    prepTime: undefined,
    cookTime: undefined,
    servings: undefined,
    cuisine: undefined,
    tags: [],
    ingredients,
    steps,
    sourceUrl,
    sourceDomain: "eda.ru",
    confidence: "medium",
  };
}

function parsePovarenok(html: string, sourceUrl: string): ImportedRecipe | null {
  const $ = cheerio.load(html);

  const title = $('h1').first().text().trim();
  if (!title) return null;

  const ingredients: Array<{ name: string; amount: string; unit: string }> = [];
  $('.ingredients li, .ingredient-item').each((_, el) => {
    const text = $(el).text().trim();
    if (text) {
      const parsed = parseIngredientText(text);
      ingredients.push(parsed);
    }
  });

  const steps: Array<{ text: string }> = [];
  $('.cooking-step, .step-description').each((_, el) => {
    const text = $(el).text().trim();
    if (text) {
      steps.push({ text });
    }
  });

  return {
    title,
    description: $('.description').first().text().trim() || undefined,
    imageUrl: $('img.recipe-image').first().attr("src") || $('meta[property="og:image"]').attr("content"),
    prepTime: undefined,
    cookTime: undefined,
    servings: undefined,
    cuisine: undefined,
    tags: [],
    ingredients,
    steps,
    sourceUrl,
    sourceDomain: "povarenok.ru",
    confidence: "medium",
  };
}

function parseGotovimDoma(html: string, sourceUrl: string): ImportedRecipe | null {
  const $ = cheerio.load(html);

  const title = $('h1[itemprop="name"]').text().trim() || $('h1').first().text().trim();
  if (!title) return null;

  const ingredients: Array<{ name: string; amount: string; unit: string }> = [];
  $('[itemprop="recipeIngredient"], .ingredient').each((_, el) => {
    const text = $(el).text().trim();
    if (text) {
      const parsed = parseIngredientText(text);
      ingredients.push(parsed);
    }
  });

  const steps: Array<{ text: string }> = [];
  $('[itemprop="recipeInstructions"] p, .step-text').each((_, el) => {
    const text = $(el).text().trim();
    if (text) {
      steps.push({ text });
    }
  });

  return {
    title,
    description: $('[itemprop="description"]').text().trim() || undefined,
    imageUrl: $('img[itemprop="image"]').attr("src") || $('meta[property="og:image"]').attr("content"),
    prepTime: parseDuration($('[itemprop="prepTime"]').attr("content")),
    cookTime: parseDuration($('[itemprop="cookTime"]').attr("content")),
    servings: parseInt($('[itemprop="recipeYield"]').text()) || undefined,
    cuisine: undefined,
    tags: [],
    ingredients,
    steps,
    sourceUrl,
    sourceDomain: "gotovim-doma.ru",
    confidence: "medium",
  };
}

function parseAllRecipes(html: string, sourceUrl: string): ImportedRecipe | null {
  // AllRecipes –æ–±—ã—á–Ω–æ –∏–º–µ–µ—Ç —Ö–æ—Ä–æ—à—É—é JSON-LD —Ä–∞–∑–º–µ—Ç–∫—É, –Ω–æ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
  const $ = cheerio.load(html);

  const title = $('h1').first().text().trim();
  if (!title) return null;

  const ingredients: Array<{ name: string; amount: string; unit: string }> = [];
  $('[data-ingredient], .ingredients-item').each((_, el) => {
    const text = $(el).text().trim();
    if (text) {
      const parsed = parseIngredientText(text);
      ingredients.push(parsed);
    }
  });

  const steps: Array<{ text: string }> = [];
  $('.recipe-directions__list--item, .instructions-section-item').each((_, el) => {
    const text = $(el).text().trim();
    if (text && !text.toLowerCase().includes("advertisement")) {
      steps.push({ text });
    }
  });

  return {
    title,
    description: $('.recipe-summary').text().trim() || undefined,
    imageUrl: $('img.recipe-image').attr("src") || $('meta[property="og:image"]').attr("content"),
    prepTime: undefined,
    cookTime: undefined,
    servings: undefined,
    cuisine: undefined,
    tags: [],
    ingredients,
    steps,
    sourceUrl,
    sourceDomain: new URL(sourceUrl).hostname,
    confidence: "medium",
  };
}

// ============================================================================
// 3. Fallback: OpenGraph + –±–∞–∑–æ–≤—ã–π HTML –ø–∞—Ä—Å–∏–Ω–≥
// ============================================================================

function extractFromOpenGraphAndHtml(html: string, sourceUrl: string): ImportedRecipe {
  const $ = cheerio.load(html);
  const domain = new URL(sourceUrl).hostname;

  // –ò–∑–≤–ª–µ–∫–∞–µ–º OpenGraph –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
  const title =
    $('meta[property="og:title"]').attr("content") ||
    $('meta[name="twitter:title"]').attr("content") ||
    $("title").text().split("|")[0].split("-")[0].trim() ||
    $("h1").first().text().trim() ||
    "–†–µ—Ü–µ–ø—Ç";

  const description =
    $('meta[property="og:description"]').attr("content") ||
    $('meta[name="description"]').attr("content") ||
    $('meta[name="twitter:description"]').attr("content");

  const imageUrl =
    $('meta[property="og:image"]').attr("content") ||
    $('meta[name="twitter:image"]').attr("content") ||
    $("img").first().attr("src");

  // –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã –∏ —à–∞–≥–∏ –≤ HTML
  const ingredients: Array<{ name: string; amount: string; unit: string }> = [];
  $("li, p").each((_, el) => {
    const text = $(el).text().trim();
    // –ü—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞: –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ü–∏—Ñ—Ä—É –∏ –µ–¥–∏–Ω–∏—Ü—É –∏–∑–º–µ—Ä–µ–Ω–∏—è, —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç
    if (text.length > 5 && text.length < 200 && /\d/.test(text)) {
      const parsed = parseIngredientText(text);
      if (parsed.name) {
        ingredients.push(parsed);
      }
    }
  });

  const steps: Array<{ text: string }> = [];
  $("ol li, .step, [class*='instruction']").each((_, el) => {
    const text = $(el).text().trim();
    if (text.length > 10 && text.length < 1000) {
      steps.push({ text });
    }
  });

  return {
    title,
    description,
    imageUrl,
    prepTime: undefined,
    cookTime: undefined,
    servings: undefined,
    cuisine: undefined,
    tags: [],
    ingredients: ingredients.slice(0, 20), // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–æ 20
    steps: steps.slice(0, 20),
    sourceUrl,
    sourceDomain: domain,
    confidence: "low",
  };
}

// ============================================================================
// –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞
// ============================================================================

function getString(value: any): string | undefined {
  if (typeof value === "string") return value.trim() || undefined;
  return undefined;
}

function getStringArray(value: any): string[] {
  if (Array.isArray(value)) {
    return value.map(v => typeof v === "string" ? v.trim() : "").filter(Boolean);
  }
  if (typeof value === "string") {
    return value.split(",").map(s => s.trim()).filter(Boolean);
  }
  return [];
}

function getImageUrl(value: any): string | undefined {
  if (typeof value === "string") return value;
  if (Array.isArray(value) && value.length > 0) {
    const first = value[0];
    return typeof first === "string" ? first : first?.url;
  }
  if (value && typeof value === "object") {
    return value.url || value.contentUrl;
  }
  return undefined;
}

function parseDuration(value: any): number | undefined {
  if (!value) return undefined;

  const str = String(value);

  // ISO 8601 —Ñ–æ—Ä–º–∞—Ç: PT1H30M –∏–ª–∏ PT30M
  const isoMatch = str.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
  if (isoMatch) {
    const hours = parseInt(isoMatch[1] || "0");
    const minutes = parseInt(isoMatch[2] || "0");
    return hours * 60 + minutes;
  }

  // –ü—Ä–æ—Å—Ç–æ–π —Ç–µ–∫—Å—Ç: "1 hour 30 minutes"
  const hourMatch = str.match(/(\d+)\s*(?:hour|—á–∞—Å)/i);
  const minMatch = str.match(/(\d+)\s*(?:minute|–º–∏–Ω)/i);

  let total = 0;
  if (hourMatch) total += parseInt(hourMatch[1]) * 60;
  if (minMatch) total += parseInt(minMatch[1]);

  return total || undefined;
}

function parseServings(value: any): number | undefined {
  if (typeof value === "number") return value;
  if (typeof value === "string") {
    const match = value.match(/(\d+)/);
    return match ? parseInt(match[1]) : undefined;
  }
  return undefined;
}

function parseIngredients(value: any): Array<{ name: string; amount: string; unit: string }> {
  if (!value) return [];

  const items: string[] = [];

  if (Array.isArray(value)) {
    items.push(...value.map(v => typeof v === "string" ? v : "").filter(Boolean));
  } else if (typeof value === "string") {
    items.push(...value.split("\n").filter(Boolean));
  }

  return items.map(parseIngredientText);
}

function parseInstructions(value: any): Array<{ text: string }> {
  if (!value) return [];

  const steps: string[] = [];

  if (Array.isArray(value)) {
    for (const item of value) {
      if (typeof item === "string") {
        steps.push(item);
      } else if (item && typeof item === "object") {
        const text = item.text || item.name || item["@type"];
        if (typeof text === "string") steps.push(text);
      }
    }
  } else if (typeof value === "string") {
    steps.push(...value.split("\n").filter(s => s.trim().length > 0));
  }

  return steps.map(text => ({ text: text.trim() }));
}

// –£–ª—É—á—à–µ–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤
function parseIngredientText(text: string): { name: string; amount: string; unit: string } {
  const cleaned = text.trim();

  // –ü–∞—Ç—Ç–µ—Ä–Ω: "200 –≥ –º—É–∫–∏" –∏–ª–∏ "2 —Å—Ç–æ–ª–æ–≤—ã–µ –ª–æ–∂–∫–∏ —Å–∞—Ö–∞—Ä–∞"
  const pattern = /^([\d\/.,]+)\s*([–∞-—è—ëa-z.]+)?\s*(.+)$/i;
  const match = cleaned.match(pattern);

  if (match) {
    const amount = match[1].replace(",", ".");
    const unit = (match[2] || "").trim();
    const name = (match[3] || "").trim();

    return { name: name || cleaned, amount, unit };
  }

  // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤–µ—Å—å —Ç–µ–∫—Å—Ç –∫–∞–∫ –Ω–∞–∑–≤–∞–Ω–∏–µ
  return { name: cleaned, amount: "", unit: "" };
}
